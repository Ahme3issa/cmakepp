


parameter_definition(build_info_evaluate_targets)
function(build_info_evaluate_targets)
  arguments_extract_defined_values(0 ${ARGC} build_info_evaluate_targets)    
  ans(build_infos)
  map_new()
  ans(evaluated_targets)
  foreach(build_info ${build_infos})    
    map_tryget(${build_info} build_parameters)
    ans(build_parameters)

    map_tryget(${build_info} id)
    ans(build_id)

    if(NOT build_parameters)
      fatal("no build parameters specified for build")
      # todo maybe just ignoriung is enough 
    endif()

    ## get the build descriptor template for current build
    map_tryget(${build_info} build_descriptor)
    ans(build_descriptor)

    ## get target templates generated by build
    map_tryget(${build_descriptor} targets)
    ans(build_targets)

    ## a single build info can have multiple targets
    map_template_evaluate_scoped("${build_parameters}" "${build_targets}")
    ans(evaluated_build_targets)

    foreach(evaluated_build_target ${evaluated_build_targets})
      map_tryget("${evaluated_build_target}" name)
      ans(target_name)
      if(NOT target_name)
        set(target_name "default")
        map_set(${evaluated_build_target} name "${target_name}")
      endif()
      map_set(${evaluated_build_target} build_id ${build_id})
      map_set(${evaluated_build_target} build_parameters ${build_parameters})
      map_append(${evaluated_targets} "${target_name}" "${evaluated_build_target}")
    endforeach()

  endforeach()
  return(${evaluated_targets})
endfunction()



  # if(NOT target_namespace)
  #   log("no target namespace is specified - defaulting to package id '${package_id}'")
  #   string_to_target_name("${package_id}")
  #   ans(target_namespace)
  # endif()


parameter_definition(cmake_target_from_build_info_targets
  <--target-namespace{"namespace for targets of package handle"}=>target_namespace:<target_identifier>>
  )
function(cmake_target_from_build_info_targets)
  arguments_extract_defined_values(0 ${ARGC} cmake_target_from_build_info_targets)    
  ans(target_configurations)


  assign(name = target_configurations[:].name)

  list_unique(name)
  ans(name)

  list(LENGTH name size )
  if(NOT "${size}" STREQUAL "1")
    fatal("all build info targets need to have the same name")
  endif()

  if(NOT name OR "${name}_" STREQUAL "default_")
    set(cmake_target_name "${target_namespace}")
  else()
    set(cmake_target_name "${target_namespace}::${name}")
  endif()



  foreach(target_configuration ${target_configurations})      
    map_set_default("${target_configuration}" cmake_target_name "${cmake_target_name}")
  endforeach()

  #assign(ids = target_configurations[:].build_id)

  assign(configs  = )


  map_new()
  ans(cmake_target)
  map_set(${cmake_target} name "${cmake_target_name}")


  json_print(${target_configurations})



  return(${cmake_target})
  

endfunction()


parameter_definition(build_info_targets_import
  <--target-namespace{"namespace for targets of package handle"}=>target_namespace:<target_identifier>>
  )
function(build_info_targets_import)
  arguments_extract_defined_values(0 ${ARGC} build_info_targets_import)    
  ans(build_infos)

  log("trying to import builds to target-namespace '${target_namespace}'")

  build_info_evaluate_targets(${build_infos})
  ans(evaluated_targets)

  if(NOT evaluated_targets)
    fatal("could not evaluated targets")
  endif()

  map_keys(${evaluated_targets})
  ans(package_target_names)

  set(cmake_target)
  foreach(package_target_name ${package_target_names})
    map_tryget(${evaluated_targets} "${package_target_name}")
    ans(target_configurations)

    cmake_target_from_build_info_targets("${target_namespace}" ${target_configurations})
    ans_append(cmake_targets)


  endforeach()

  return_ref(cmake_targets)


  return(${evaluated_targets})


  # set(bin_dir bin)
  # set(lib_dir lib)


  # set(include_dirs)
  # set(implib)
  # set(location)
  # set(configs)

  #   map_tryget(${build_parameters} install_dir)
  #   ans(install_dir)

  #   set(include_dir include)



  #   map_tryget("${build_parameters}" config)
  #   ans(cfg)   
  #   string_toupper("${cfg}")
  #   ans(cfg)
  #   list(APPEND configs "${cfg}")

  #   glob("${install_dir}/${bin_dir}/*${CMAKE_SHARED_MODULE_SUFFIX}")
  #   ans(shared_lib)


  #   glob("${install_dir}/${lib_dir}/*${CMAKE_STATIC_LIBRARY_SUFFIX}")
  #   ans(static_lib)

    
  #   set(include_dirs ${include_dirs} "$<$<CONFIG:${cfg}>:${install_dir}/${include_dir}>")


  #   if(shared_lib)
  #     if(NOT location)
  #       map_new()
  #       ans(location)
  #     endif()
  #     list(LENGTH shared_lib nLibs)
  #     if("${nLibs}" GREATER 1)
  #       message(FATAL_ERROR "cannot handle shared nlibs greater 1")
  #     endif()
  #     map_set("${location}" "${cfg}" "${shared_lib}")
  #   endif()

  #   if(static_lib)
  #     if(NOT implib)
  #       map_new()
  #       ans(implib)
  #     endif()

  #     list(LENGTH implib nLibs)
  #     if("${nLibs}" GREATER 1)
  #       message(FATAL_ERROR "cannot handle implib nlibs greater 1")        
  #     endif()
  #     map_set("${implib}" "${cfg}" "${static_lib}")
  #   endif()


  # set(global GLOBAL)
  # set(linkage SHARED ) # STATIC, INTERFACE


  # if(NOT location AND NOT implib)
  #   set(linkage INTERFACE)  
  # else()


  # endif()

  # if(location) 
  #   set(linkage SHARED)
  # elseif(location )
  # endif()

  # add_library(${target_name} ${linkage} IMPORTED ${global})
  # target_set(${target_name} INTERFACE_INCLUDE_DIRECTORIES ${include_dirs})


  # if(implib)
  #   map_keys(${implib})
  #   ans(cfgs)
  #   foreach(cfg ${cfgs})
  #     map_tryget(${implib} ${cfg})
  #     ans(lib)
  #     target_set(${target_name} "IMPORTED_IMPLIB_${cfg}" "${lib}")
  #   endforeach()
  # endif()

  # if(location)
  #   map_keys(${location})
  #   ans(cfgs)
  #   foreach(cfg ${cfgs})
  #     map_tryget(${location} ${cfg})
  #     ans(loc)
  #     target_set(${target_name} "IMPORTED_LOCATION_${cfg}" "${loc}")
  #   endforeach()
  # endif()

  # return(${target_name})

endfunction()

